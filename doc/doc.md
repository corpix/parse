<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# parse

```go
import "github.com/corpix/parse"
```

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func EqualSlicesFold(a, b []string) bool](<#EqualSlicesFold>)
- [func EqualSlicesFoldPrefix(a, prefix []string) bool](<#EqualSlicesFoldPrefix>)
- [func EqualSlicesFoldSome(a []string, b ...[]string) bool](<#EqualSlicesFoldSome>)
- [func EqualSlicesFoldSuffix(a, suffix []string) bool](<#EqualSlicesFoldSuffix>)
- [func NewErrBoundIncomplete(starting, closing []byte, l *Location) error](<#NewErrBoundIncomplete>)
- [func NewErrEmptyRule(rule Rule, inside Rule) error](<#NewErrEmptyRule>)
- [func NewErrNestingTooDeep(l *Location, depth int) error](<#NewErrNestingTooDeep>)
- [func NewErrRepetitionNotEnoughOccurrences(want, got int) error](<#NewErrRepetitionNotEnoughOccurrences>)
- [func NewErrRepetitionTooMuchOccurrences(want, got int) error](<#NewErrRepetitionTooMuchOccurrences>)
- [func NewErrUnexpectedEOF(r Rule, l *Location) error](<#NewErrUnexpectedEOF>)
- [func NewErrUnexpectedToken(r Rule, l *Location, token []byte, inner ...error) error](<#NewErrUnexpectedToken>)
- [func NewErrUnmatchedInput(input []byte) error](<#NewErrUnmatchedInput>)
- [func NewErrUnsupportedRule(rule Rule) error](<#NewErrUnsupportedRule>)
- [func RuleShow(rule Rule, parameters string, childs string) string](<#RuleShow>)
- [func ShowInput(buf []byte) []byte](<#ShowInput>)
- [func TreeShow(tree *Tree, rule string, childs string) string](<#TreeShow>)
- [func TreerString(t Treer) string](<#TreerString>)
- [func WalkTreerBFS(tree Treer, fn func(int, Treer) error) error](<#WalkTreerBFS>)
- [func WalkTreerDFS(tree Treer, fn func(int, Treer) error) error](<#WalkTreerDFS>)
- [func WalkTreerNameChainBFS(tree Treer, fn func([]string, int, Treer) error) error](<#WalkTreerNameChainBFS>)
- [func WalkTreerNameChainDFS(tree Treer, fn func([]string, int, Treer) error) error](<#WalkTreerNameChainDFS>)
- [func indent(s string, character string, size int) string](<#indent>)
- [func indirectValue(reflectValue reflect.Value) reflect.Value](<#indirectValue>)
- [func treerString(t Treer, visited map[interface{}]bool) string](<#treerString>)
- [type AllMatcher](<#AllMatcher>)
  - [func NewAllMatcher(matchers []Matcher) AllMatcher](<#NewAllMatcher>)
  - [func (m AllMatcher) Match(chain []string) bool](<#AllMatcher.Match>)
- [type Chain](<#Chain>)
  - [func NewChain(name string, rulesOrHooks ...interface{}) *Chain](<#NewChain>)
  - [func (r *Chain) Add(rule ...Rule)](<#Chain.Add>)
  - [func (r *Chain) GetChilds() Treers](<#Chain.GetChilds>)
  - [func (r *Chain) GetParameters() RuleParameters](<#Chain.GetParameters>)
  - [func (r *Chain) IsFinite() bool](<#Chain.IsFinite>)
  - [func (r *Chain) Name() string](<#Chain.Name>)
  - [func (r *Chain) Parse(ctx *Context, input []byte) (*Tree, error)](<#Chain.Parse>)
  - [func (r *Chain) Show(childs string) string](<#Chain.Show>)
  - [func (r *Chain) String() string](<#Chain.String>)
- [type Context](<#Context>)
- [type Either](<#Either>)
  - [func NewASCIIRange(name string, from byte, to byte, hooks ...RuleParseHook) *Either](<#NewASCIIRange>)
  - [func NewEither(name string, rulesOrHooks ...interface{}) *Either](<#NewEither>)
  - [func (r *Either) Add(rule ...Rule)](<#Either.Add>)
  - [func (r *Either) GetChilds() Treers](<#Either.GetChilds>)
  - [func (r *Either) GetParameters() RuleParameters](<#Either.GetParameters>)
  - [func (r *Either) IsFinite() bool](<#Either.IsFinite>)
  - [func (r *Either) Name() string](<#Either.Name>)
  - [func (r *Either) Parse(ctx *Context, input []byte) (*Tree, error)](<#Either.Parse>)
  - [func (r *Either) Show(childs string) string](<#Either.Show>)
  - [func (r *Either) String() string](<#Either.String>)
- [type EqualMatcher](<#EqualMatcher>)
  - [func NewEqualMatcher(sample []string) EqualMatcher](<#NewEqualMatcher>)
  - [func (m EqualMatcher) Match(chain []string) bool](<#EqualMatcher.Match>)
- [type ErrBoundIncomplete](<#ErrBoundIncomplete>)
  - [func (e *ErrBoundIncomplete) Error() string](<#ErrBoundIncomplete.Error>)
- [type ErrEmptyRule](<#ErrEmptyRule>)
  - [func (e *ErrEmptyRule) Error() string](<#ErrEmptyRule.Error>)
- [type ErrNestingTooDeep](<#ErrNestingTooDeep>)
  - [func (e *ErrNestingTooDeep) Error() string](<#ErrNestingTooDeep.Error>)
- [type ErrUnexpectedEOF](<#ErrUnexpectedEOF>)
  - [func (e *ErrUnexpectedEOF) Error() string](<#ErrUnexpectedEOF.Error>)
- [type ErrUnexpectedToken](<#ErrUnexpectedToken>)
  - [func (e *ErrUnexpectedToken) Error() string](<#ErrUnexpectedToken.Error>)
- [type ErrUnsupportedRule](<#ErrUnsupportedRule>)
  - [func (e *ErrUnsupportedRule) Error() string](<#ErrUnsupportedRule.Error>)
- [type LengthMatcher](<#LengthMatcher>)
  - [func NewLengthMatcher(length int) LengthMatcher](<#NewLengthMatcher>)
  - [func (m LengthMatcher) Match(chain []string) bool](<#LengthMatcher.Match>)
- [type Location](<#Location>)
  - [func (l *Location) String() string](<#Location.String>)
- [type Matcher](<#Matcher>)
- [type Parser](<#Parser>)
  - [func NewParser(op ...ParserOption) *Parser](<#NewParser>)
  - [func (p *Parser) LineRegions(input []byte) []*Region](<#Parser.LineRegions>)
  - [func (p *Parser) Locate(position int) (int, int)](<#Parser.Locate>)
  - [func (p *Parser) Parse(r Rule, input []byte) (*Tree, error)](<#Parser.Parse>)
- [type ParserOption](<#ParserOption>)
  - [func ParserOptionLineBreak(r Rule) ParserOption](<#ParserOptionLineBreak>)
  - [func ParserOptionMaxDepth(d int) ParserOption](<#ParserOptionMaxDepth>)
  - [func ParserOptionPath(path string) ParserOption](<#ParserOptionPath>)
- [type PrefixMatcher](<#PrefixMatcher>)
  - [func NewPrefixMatcher(prefix []string) PrefixMatcher](<#NewPrefixMatcher>)
  - [func (m PrefixMatcher) Match(chain []string) bool](<#PrefixMatcher.Match>)
- [type Regexp](<#Regexp>)
  - [func NewRegexp(name string, expr string, hooks ...RuleParseHook) *Regexp](<#NewRegexp>)
  - [func (r *Regexp) GetChilds() Treers](<#Regexp.GetChilds>)
  - [func (r *Regexp) GetParameters() RuleParameters](<#Regexp.GetParameters>)
  - [func (r *Regexp) IsFinite() bool](<#Regexp.IsFinite>)
  - [func (r *Regexp) Name() string](<#Regexp.Name>)
  - [func (r *Regexp) Parse(ctx *Context, input []byte) (*Tree, error)](<#Regexp.Parse>)
  - [func (r *Regexp) Show(childs string) string](<#Regexp.Show>)
  - [func (r *Regexp) String() string](<#Regexp.String>)
- [type Region](<#Region>)
  - [func TreeRegion(tree ...*Tree) *Region](<#TreeRegion>)
- [type Repetition](<#Repetition>)
  - [func NewRepetition(name string, rule Rule, hooks ...RuleParseHook) *Repetition](<#NewRepetition>)
  - [func NewRepetitionTimes(name string, times int, rule Rule, hooks ...RuleParseHook) *Repetition](<#NewRepetitionTimes>)
  - [func NewRepetitionTimesVariadic(name string, times int, rule Rule, hooks ...RuleParseHook) *Repetition](<#NewRepetitionTimesVariadic>)
  - [func (r *Repetition) GetChilds() Treers](<#Repetition.GetChilds>)
  - [func (r *Repetition) GetParameters() RuleParameters](<#Repetition.GetParameters>)
  - [func (r *Repetition) IsFinite() bool](<#Repetition.IsFinite>)
  - [func (r *Repetition) Name() string](<#Repetition.Name>)
  - [func (r *Repetition) Parse(ctx *Context, input []byte) (*Tree, error)](<#Repetition.Parse>)
  - [func (r *Repetition) Show(childs string) string](<#Repetition.Show>)
  - [func (r *Repetition) String() string](<#Repetition.String>)
- [type Rule](<#Rule>)
- [type RuleParameters](<#RuleParameters>)
  - [func (p RuleParameters) String() string](<#RuleParameters.String>)
- [type RuleParseHook](<#RuleParseHook>)
- [type Rules](<#Rules>)
- [type SomeMatcher](<#SomeMatcher>)
  - [func NewSomeMatcher(matchers []Matcher) SomeMatcher](<#NewSomeMatcher>)
  - [func (m SomeMatcher) Match(chain []string) bool](<#SomeMatcher.Match>)
- [type SuffixMatcher](<#SuffixMatcher>)
  - [func NewSuffixMatcher(suffix []string) SuffixMatcher](<#NewSuffixMatcher>)
  - [func (m SuffixMatcher) Match(chain []string) bool](<#SuffixMatcher.Match>)
- [type Terminal](<#Terminal>)
  - [func NewTerminal(name string, v string, hooks ...RuleParseHook) *Terminal](<#NewTerminal>)
  - [func (r *Terminal) GetChilds() Treers](<#Terminal.GetChilds>)
  - [func (r *Terminal) GetParameters() RuleParameters](<#Terminal.GetParameters>)
  - [func (r *Terminal) IsFinite() bool](<#Terminal.IsFinite>)
  - [func (r *Terminal) Name() string](<#Terminal.Name>)
  - [func (r *Terminal) Parse(ctx *Context, input []byte) (*Tree, error)](<#Terminal.Parse>)
  - [func (r *Terminal) Show(childs string) string](<#Terminal.Show>)
  - [func (r *Terminal) String() string](<#Terminal.String>)
- [type Tree](<#Tree>)
  - [func Parse(rule Rule, input []byte) (*Tree, error)](<#Parse>)
  - [func (t *Tree) GetChilds() Treers](<#Tree.GetChilds>)
  - [func (t *Tree) Graph() string](<#Tree.Graph>)
  - [func (t *Tree) Hash() string](<#Tree.Hash>)
  - [func (t *Tree) Name() string](<#Tree.Name>)
  - [func (t *Tree) Show(childs string) string](<#Tree.Show>)
  - [func (t *Tree) String() string](<#Tree.String>)
  - [func (t *Tree) graph() string](<#Tree.graph>)
- [type Treer](<#Treer>)
  - [func FindFirstDFSPrefix(tree Treer, prefix []string) (Treer, bool)](<#FindFirstDFSPrefix>)
  - [func FindFirstDFSSuffix(tree Treer, suffix []string) (Treer, bool)](<#FindFirstDFSSuffix>)
- [type Treers](<#Treers>)
- [type Wrapper](<#Wrapper>)
  - [func NewWrapper(name string, r Rule, hooks ...RuleParseHook) *Wrapper](<#NewWrapper>)
  - [func (r *Wrapper) GetChilds() Treers](<#Wrapper.GetChilds>)
  - [func (r *Wrapper) GetParameters() RuleParameters](<#Wrapper.GetParameters>)
  - [func (r *Wrapper) IsFinite() bool](<#Wrapper.IsFinite>)
  - [func (r *Wrapper) Name() string](<#Wrapper.Name>)
  - [func (r *Wrapper) Parse(ctx *Context, input []byte) (*Tree, error)](<#Wrapper.Parse>)
  - [func (r *Wrapper) Show(childs string) string](<#Wrapper.Show>)
  - [func (r *Wrapper) String() string](<#Wrapper.String>)


## Constants

<a name="newLine"></a>

```go
const (
    newLine              = "\n"
    treerIndentCharacter = " "
    treerDelimiter       = ", "
)
```

<a name="circularLabel"></a>

```go
const (
    circularLabel = "<circular>"
    nilLabel      = "<nil>"
)
```

<a name="treerIndentSize"></a>

```go
const (
    treerIndentSize = 2
)
```

## Variables

<a name="ErrStopIteration"></a>

```go
var (
    ErrStopIteration = e.New("Stop iteration")
    ErrSkipBranch    = e.New("Skip branch")
    ErrSkipRule      = e.New("Skip rule")
)
```

<a name="DefaultParserMaxDepth"></a>

```go
var (
    DefaultParserMaxDepth  = 128
    DefaultParserLineBreak = NewEither(
        "line-break",
        NewTerminal("lf", "\n"),
        NewTerminal("crlf", "\r\n"),
    )
    DefaultParserPath    = "?"
    DefaultParserOptions = []ParserOption{
        ParserOptionMaxDepth(DefaultParserMaxDepth),
        ParserOptionLineBreak(DefaultParserLineBreak),
        ParserOptionPath(DefaultParserPath),
    }

    // DefaultParser is a Parser with default settings.
    DefaultParser = NewParser(DefaultParserOptions...)
)
```

<a name="ErrRepetitionNothingMatched"></a>

```go
var ErrRepetitionNothingMatched = fmt.Errorf("nothing matched")
```

<a name="EqualSlicesFold"></a>
## func [EqualSlicesFold](<https://github.com/corpix/parse/blob/master/strings.go#L52>)

```go
func EqualSlicesFold(a, b []string) bool
```

EqualSlicesFold checks that all elements from a exists in b with strings.EqualFold.

<a name="EqualSlicesFoldPrefix"></a>
## func [EqualSlicesFoldPrefix](<https://github.com/corpix/parse/blob/master/strings.go#L20>)

```go
func EqualSlicesFoldPrefix(a, prefix []string) bool
```

EqualSlicesFoldPrefix checks that a is prefixed or equal with prefix via EqualSlicesFold.

<a name="EqualSlicesFoldSome"></a>
## func [EqualSlicesFoldSome](<https://github.com/corpix/parse/blob/master/strings.go#L66>)

```go
func EqualSlicesFoldSome(a []string, b ...[]string) bool
```

EqualSlicesFoldSome checks that all elements from a exists in one of b items with EqualSlicesFold.

<a name="EqualSlicesFoldSuffix"></a>
## func [EqualSlicesFoldSuffix](<https://github.com/corpix/parse/blob/master/strings.go#L36>)

```go
func EqualSlicesFoldSuffix(a, suffix []string) bool
```

EqualSlicesFoldSuffix checks that a is suffixed or equal with suffix via EqualSlicesFold.

<a name="NewErrBoundIncomplete"></a>
## func [NewErrBoundIncomplete](<https://github.com/corpix/parse/blob/master/errors.go#L34>)

```go
func NewErrBoundIncomplete(starting, closing []byte, l *Location) error
```

NewErrBoundIncomplete constructs new ErrBoundIncomplete.

<a name="NewErrEmptyRule"></a>
## func [NewErrEmptyRule](<https://github.com/corpix/parse/blob/master/errors.go#L165>)

```go
func NewErrEmptyRule(rule Rule, inside Rule) error
```

NewErrEmptyRule constructs new ErrEmptyRule.

<a name="NewErrNestingTooDeep"></a>
## func [NewErrNestingTooDeep](<https://github.com/corpix/parse/blob/master/errors.go#L136>)

```go
func NewErrNestingTooDeep(l *Location, depth int) error
```

NewErrNestingTooDeep constructs new ErrNestingTooDeep.

<a name="NewErrRepetitionNotEnoughOccurrences"></a>
## func [NewErrRepetitionNotEnoughOccurrences](<https://github.com/corpix/parse/blob/master/repetition.go#L16>)

```go
func NewErrRepetitionNotEnoughOccurrences(want, got int) error
```



<a name="NewErrRepetitionTooMuchOccurrences"></a>
## func [NewErrRepetitionTooMuchOccurrences](<https://github.com/corpix/parse/blob/master/repetition.go#L9>)

```go
func NewErrRepetitionTooMuchOccurrences(want, got int) error
```



<a name="NewErrUnexpectedEOF"></a>
## func [NewErrUnexpectedEOF](<https://github.com/corpix/parse/blob/master/errors.go#L77>)

```go
func NewErrUnexpectedEOF(r Rule, l *Location) error
```

NewErrUnexpectedEOF constructs new ErrUnexpectedEOF.

<a name="NewErrUnexpectedToken"></a>
## func [NewErrUnexpectedToken](<https://github.com/corpix/parse/blob/master/errors.go#L109>)

```go
func NewErrUnexpectedToken(r Rule, l *Location, token []byte, inner ...error) error
```

NewErrUnexpectedToken constructs new ErrUnexpectedToken.

<a name="NewErrUnmatchedInput"></a>
## func [NewErrUnmatchedInput](<https://github.com/corpix/parse/blob/master/parse.go#L26>)

```go
func NewErrUnmatchedInput(input []byte) error
```



<a name="NewErrUnsupportedRule"></a>
## func [NewErrUnsupportedRule](<https://github.com/corpix/parse/blob/master/errors.go#L54>)

```go
func NewErrUnsupportedRule(rule Rule) error
```

NewErrUnsupportedRule constructs new ErrUnsupportedRule.

<a name="RuleShow"></a>
## func [RuleShow](<https://github.com/corpix/parse/blob/master/rule.go#L63>)

```go
func RuleShow(rule Rule, parameters string, childs string) string
```

RuleShow returns a Rule encoded as a string. It requires some parts to be prepared\(encoded into a string\).

<a name="ShowInput"></a>
## func [ShowInput](<https://github.com/corpix/parse/blob/master/util.go#L9>)

```go
func ShowInput(buf []byte) []byte
```

ShowInput return a byte slice of input and formats it with ellipsis, preparing it to be printed to human.

<a name="TreeShow"></a>
## func [TreeShow](<https://github.com/corpix/parse/blob/master/tree.go#L100>)

```go
func TreeShow(tree *Tree, rule string, childs string) string
```

TreeShow returns a Tree encoded as a string. It requires some parts to be prepared\(encoded into a string\).

<a name="TreerString"></a>
## func [TreerString](<https://github.com/corpix/parse/blob/master/treer_string.go#L60>)

```go
func TreerString(t Treer) string
```

TreerString prints a Treer as human\-readable string.

<a name="WalkTreerBFS"></a>
## func [WalkTreerBFS](<https://github.com/corpix/parse/blob/master/treer_walk.go#L5>)

```go
func WalkTreerBFS(tree Treer, fn func(int, Treer) error) error
```

WalkTreerBFS walks the Treer level by level. See: https://en.wikipedia.org/wiki/Breadth-first_search[https://en.wikipedia.org/wiki/Breadth-first_search](<https://en.wikipedia.org/wiki/Breadth-first_search>)

<a name="WalkTreerDFS"></a>
## func [WalkTreerDFS](<https://github.com/corpix/parse/blob/master/treer_walk.go#L126>)

```go
func WalkTreerDFS(tree Treer, fn func(int, Treer) error) error
```

WalkTreerDFS walks the Treer childs from top to leafs. See: https://en.wikipedia.org/wiki/Depth-first_search[https://en.wikipedia.org/wiki/Depth-first_search](<https://en.wikipedia.org/wiki/Depth-first_search>)

<a name="WalkTreerNameChainBFS"></a>
## func [WalkTreerNameChainBFS](<https://github.com/corpix/parse/blob/master/treer_walk.go#L67>)

```go
func WalkTreerNameChainBFS(tree Treer, fn func([]string, int, Treer) error) error
```

WalkTreerNameChainBFS is a walker which reports nesting as chain of Treer node Name's on every iteration and uses WalkerTreerBFS.

<a name="WalkTreerNameChainDFS"></a>
## func [WalkTreerNameChainDFS](<https://github.com/corpix/parse/blob/master/treer_walk.go#L178>)

```go
func WalkTreerNameChainDFS(tree Treer, fn func([]string, int, Treer) error) error
```

WalkTreerNameChainDFS is a walker which reports nesting as chain of Treer node Name's on every iteration and uses WalkerTreerDFS.

<a name="indent"></a>
## func [indent](<https://github.com/corpix/parse/blob/master/strings.go#L7>)

```go
func indent(s string, character string, size int) string
```



<a name="indirectValue"></a>
## func [indirectValue](<https://github.com/corpix/parse/blob/master/util.go#L48>)

```go
func indirectValue(reflectValue reflect.Value) reflect.Value
```



<a name="treerString"></a>
## func [treerString](<https://github.com/corpix/parse/blob/master/treer_string.go#L20>)

```go
func treerString(t Treer, visited map[interface{}]bool) string
```

treerString folds a tree into string representation\(with \`Show\`\) while resolving the pointer loops.

<a name="AllMatcher"></a>
## type [AllMatcher](<https://github.com/corpix/parse/blob/master/matcher.go#L13>)

AllMatcher represents a Matcher which wraps a slice of Matcher where each Matcher should match for the wrapper to be true.

```go
type AllMatcher []Matcher
```

<a name="NewAllMatcher"></a>
### func [NewAllMatcher](<https://github.com/corpix/parse/blob/master/matcher.go#L32>)

```go
func NewAllMatcher(matchers []Matcher) AllMatcher
```

NewAllMatcher creates new AllMatcher.

<a name="AllMatcher.Match"></a>
### func \(AllMatcher\) [Match](<https://github.com/corpix/parse/blob/master/matcher.go#L19>)

```go
func (m AllMatcher) Match(chain []string) bool
```

Match checks that every Matcher.Match\(...\) returns true and returns true too, otherwise it returns false. If no Matcher presented in a slice then it will return false.

<a name="Chain"></a>
## type [Chain](<https://github.com/corpix/parse/blob/master/chain.go#L10-L14>)

Chain represents a chain of Rule's to match in the data.

```go
type Chain struct {
    name  string
    Rules Rules
    Hooks []RuleParseHook
}
```

<a name="NewChain"></a>
### func [NewChain](<https://github.com/corpix/parse/blob/master/chain.go#L153>)

```go
func NewChain(name string, rulesOrHooks ...interface{}) *Chain
```

NewChain constructs new Chain. Valid Chain could be constructed with \>=2 rules.

<a name="Chain.Add"></a>
### func \(\*Chain\) [Add](<https://github.com/corpix/parse/blob/master/chain.go#L145>)

```go
func (r *Chain) Add(rule ...Rule)
```

Add appends a Rule to the Chain.

<a name="Chain.GetChilds"></a>
### func \(\*Chain\) [GetChilds](<https://github.com/corpix/parse/blob/master/chain.go#L43>)

```go
func (r *Chain) GetChilds() Treers
```

GetChilds returns a slice of Rule which is children for current Rule.

<a name="Chain.GetParameters"></a>
### func \(\*Chain\) [GetParameters](<https://github.com/corpix/parse/blob/master/chain.go#L54>)

```go
func (r *Chain) GetParameters() RuleParameters
```

GetParameters returns a KV rule parameters.

<a name="Chain.IsFinite"></a>
### func \(\*Chain\) [IsFinite](<https://github.com/corpix/parse/blob/master/chain.go#L62>)

```go
func (r *Chain) IsFinite() bool
```

IsFinite returns true if this rule is not a wrapper for other rules.

<a name="Chain.Name"></a>
### func \(\*Chain\) [Name](<https://github.com/corpix/parse/blob/master/chain.go#L18>)

```go
func (r *Chain) Name() string
```

Name indicates the name which was given to the rule on creation. Name could be not unique.

<a name="Chain.Parse"></a>
### func \(\*Chain\) [Parse](<https://github.com/corpix/parse/blob/master/chain.go#L70>)

```go
func (r *Chain) Parse(ctx *Context, input []byte) (*Tree, error)
```

Parse consumes some bytes from input & emits a Tree using settings defined during creation of the concrete Rule type. May return an error if something goes wrong, should provide some location information to the user which points to position in input.

<a name="Chain.Show"></a>
### func \(\*Chain\) [Show](<https://github.com/corpix/parse/blob/master/chain.go#L27>)

```go
func (r *Chain) Show(childs string) string
```

Show this node as a string. You should provide childs as string to this function, it does not care about nesting in a tree, it only shows string representation of itself.

<a name="Chain.String"></a>
### func \(\*Chain\) [String](<https://github.com/corpix/parse/blob/master/chain.go#L37>)

```go
func (r *Chain) String() string
```

String returns rule as a string, resolving recursion with \`\<circular\>\` placeholder.

<a name="Context"></a>
## type [Context](<https://github.com/corpix/parse/blob/master/parse.go#L216-L221>)



```go
type Context struct {
    Rule     Rule
    Parser   *Parser
    Location *Location
    Depth    int
}
```

<a name="Either"></a>
## type [Either](<https://github.com/corpix/parse/blob/master/either.go#L11-L15>)

Either represents a list of Rule's to match in the data. One of the rules in a list must match.

```go
type Either struct {
    name  string
    Rules Rules
    Hooks []RuleParseHook
}
```

<a name="NewASCIIRange"></a>
### func [NewASCIIRange](<https://github.com/corpix/parse/blob/master/either.go#L184>)

```go
func NewASCIIRange(name string, from byte, to byte, hooks ...RuleParseHook) *Either
```

NewASCIIRange constructs \*Either\(Terminal, ...\) Rule using specified ASCII range.

<a name="NewEither"></a>
### func [NewEither](<https://github.com/corpix/parse/blob/master/either.go#L163>)

```go
func NewEither(name string, rulesOrHooks ...interface{}) *Either
```

NewEither constructs \*Either Rule. Valid Either could be constructed with \>=2 rules.

<a name="Either.Add"></a>
### func \(\*Either\) [Add](<https://github.com/corpix/parse/blob/master/either.go#L155>)

```go
func (r *Either) Add(rule ...Rule)
```

Add appends a Rule into Either list.

<a name="Either.GetChilds"></a>
### func \(\*Either\) [GetChilds](<https://github.com/corpix/parse/blob/master/either.go#L44>)

```go
func (r *Either) GetChilds() Treers
```

GetChilds returns a slice of Rule which is children for current Rule.

<a name="Either.GetParameters"></a>
### func \(\*Either\) [GetParameters](<https://github.com/corpix/parse/blob/master/either.go#L55>)

```go
func (r *Either) GetParameters() RuleParameters
```

GetParameters returns a KV rule parameters.

<a name="Either.IsFinite"></a>
### func \(\*Either\) [IsFinite](<https://github.com/corpix/parse/blob/master/either.go#L63>)

```go
func (r *Either) IsFinite() bool
```

IsFinite returns true if this rule is not a wrapper for other rules.

<a name="Either.Name"></a>
### func \(\*Either\) [Name](<https://github.com/corpix/parse/blob/master/either.go#L19>)

```go
func (r *Either) Name() string
```

Name indicates the name which was given to the rule on creation. Name could be not unique.

<a name="Either.Parse"></a>
### func \(\*Either\) [Parse](<https://github.com/corpix/parse/blob/master/either.go#L71>)

```go
func (r *Either) Parse(ctx *Context, input []byte) (*Tree, error)
```

Parse consumes some bytes from input & emits a Tree using settings defined during creation of the concrete Rule type. May return an error if something goes wrong, should provide some location information to the user which points to position in input.

<a name="Either.Show"></a>
### func \(\*Either\) [Show](<https://github.com/corpix/parse/blob/master/either.go#L28>)

```go
func (r *Either) Show(childs string) string
```

Show this node as a string. You should provide childs as string to this function, it does not care about nesting in a tree, it only shows string representation of itself.

<a name="Either.String"></a>
### func \(\*Either\) [String](<https://github.com/corpix/parse/blob/master/either.go#L38>)

```go
func (r *Either) String() string
```

String returns rule as a string, resolving recursion with \`\<circular\>\` placeholder.

<a name="EqualMatcher"></a>
## type [EqualMatcher](<https://github.com/corpix/parse/blob/master/matcher.go#L99>)

EqualMatcher represents a Matcher which is true when chain\(which should be matched\) has same elements as matcher.

```go
type EqualMatcher []string
```

<a name="NewEqualMatcher"></a>
### func [NewEqualMatcher](<https://github.com/corpix/parse/blob/master/matcher.go#L107>)

```go
func NewEqualMatcher(sample []string) EqualMatcher
```

NewEqualMatcher creates new EqualMatcher.

<a name="EqualMatcher.Match"></a>
### func \(EqualMatcher\) [Match](<https://github.com/corpix/parse/blob/master/matcher.go#L102>)

```go
func (m EqualMatcher) Match(chain []string) bool
```

Match checks chain has same elements as m.

<a name="ErrBoundIncomplete"></a>
## type [ErrBoundIncomplete](<https://github.com/corpix/parse/blob/master/errors.go#L18-L22>)

ErrBoundIncomplete is an error which mean that a closing token was not found in the input which is making a requested logical «bound» to be incomplete.

```go
type ErrBoundIncomplete struct {
    Starting []byte
    Closing  []byte
    Location *Location
}
```

<a name="ErrBoundIncomplete.Error"></a>
### func \(\*ErrBoundIncomplete\) [Error](<https://github.com/corpix/parse/blob/master/errors.go#L24>)

```go
func (e *ErrBoundIncomplete) Error() string
```



<a name="ErrEmptyRule"></a>
## type [ErrEmptyRule](<https://github.com/corpix/parse/blob/master/errors.go#L144-L147>)

ErrEmptyRule is an error which mean a Rule with empty content was passed to the parser.

```go
type ErrEmptyRule struct {
    Rule   Rule
    Inside Rule
}
```

<a name="ErrEmptyRule.Error"></a>
### func \(\*ErrEmptyRule\) [Error](<https://github.com/corpix/parse/blob/master/errors.go#L149>)

```go
func (e *ErrEmptyRule) Error() string
```



<a name="ErrNestingTooDeep"></a>
## type [ErrNestingTooDeep](<https://github.com/corpix/parse/blob/master/errors.go#L122-L125>)

ErrNestingTooDeep is an error which mean the Rule nesting is too deep.

```go
type ErrNestingTooDeep struct {
    Location *Location
    Depth    int
}
```

<a name="ErrNestingTooDeep.Error"></a>
### func \(\*ErrNestingTooDeep\) [Error](<https://github.com/corpix/parse/blob/master/errors.go#L127>)

```go
func (e *ErrNestingTooDeep) Error() string
```



<a name="ErrUnexpectedEOF"></a>
## type [ErrUnexpectedEOF](<https://github.com/corpix/parse/blob/master/errors.go#L63-L66>)

ErrUnexpectedEOF is an error which mean that EOF was meat while parser wanted more input.

```go
type ErrUnexpectedEOF struct {
    Rule     Rule
    Location *Location
}
```

<a name="ErrUnexpectedEOF.Error"></a>
### func \(\*ErrUnexpectedEOF\) [Error](<https://github.com/corpix/parse/blob/master/errors.go#L68>)

```go
func (e *ErrUnexpectedEOF) Error() string
```



<a name="ErrUnexpectedToken"></a>
## type [ErrUnexpectedToken](<https://github.com/corpix/parse/blob/master/errors.go#L86-L91>)

ErrUnexpectedToken is an error which mean that token read from current position in input is not expected by the current Rule.

```go
type ErrUnexpectedToken struct {
    Rule     Rule
    Location *Location
    Token    []byte
    Inner    []error
}
```

<a name="ErrUnexpectedToken.Error"></a>
### func \(\*ErrUnexpectedToken\) [Error](<https://github.com/corpix/parse/blob/master/errors.go#L93>)

```go
func (e *ErrUnexpectedToken) Error() string
```



<a name="ErrUnsupportedRule"></a>
## type [ErrUnsupportedRule](<https://github.com/corpix/parse/blob/master/errors.go#L42-L44>)

ErrUnsupportedRule is an error which mean that parser support for specifier Rule is not implemented.

```go
type ErrUnsupportedRule struct {
    Rule Rule
}
```

<a name="ErrUnsupportedRule.Error"></a>
### func \(\*ErrUnsupportedRule\) [Error](<https://github.com/corpix/parse/blob/master/errors.go#L46>)

```go
func (e *ErrUnsupportedRule) Error() string
```



<a name="LengthMatcher"></a>
## type [LengthMatcher](<https://github.com/corpix/parse/blob/master/matcher.go#L116>)

LengthMatcher represents a Matcher which is true when chain\(which should be matched\) has same length as int stored in matcher.

```go
type LengthMatcher int
```

<a name="NewLengthMatcher"></a>
### func [NewLengthMatcher](<https://github.com/corpix/parse/blob/master/matcher.go#L124>)

```go
func NewLengthMatcher(length int) LengthMatcher
```

NewLengthMatcher creates new LengthMatcher.

<a name="LengthMatcher.Match"></a>
### func \(LengthMatcher\) [Match](<https://github.com/corpix/parse/blob/master/matcher.go#L119>)

```go
func (m LengthMatcher) Match(chain []string) bool
```

Match checks chain length is same as int\(m\).

<a name="Location"></a>
## type [Location](<https://github.com/corpix/parse/blob/master/parse.go#L224-L229>)

Location represents position in input \(posirion, line, column\).

```go
type Location struct {
    Path     string
    Position int
    Line     int
    Column   int
}
```

<a name="Location.String"></a>
### func \(\*Location\) [String](<https://github.com/corpix/parse/blob/master/parse.go#L231>)

```go
func (l *Location) String() string
```



<a name="Matcher"></a>
## type [Matcher](<https://github.com/corpix/parse/blob/master/matcher.go#L5-L7>)

Matcher represents an interface of the object which could be checked to match to some slice of strings.

```go
type Matcher interface {
    Match(chain []string) bool
}
```

<a name="Parser"></a>
## type [Parser](<https://github.com/corpix/parse/blob/master/parse.go#L32-L37>)

Parser represents a parser which use Rule's to parse the input.

```go
type Parser struct {
    MaxDepth  int
    LineBreak Rule
    LineIndex []*Region
    Path      string
}
```

<a name="NewParser"></a>
### func [NewParser](<https://github.com/corpix/parse/blob/master/parse.go#L203>)

```go
func NewParser(op ...ParserOption) *Parser
```

NewParser constructs new \*Parser.

<a name="Parser.LineRegions"></a>
### func \(\*Parser\) [LineRegions](<https://github.com/corpix/parse/blob/master/parse.go#L66>)

```go
func (p *Parser) LineRegions(input []byte) []*Region
```

LineRegions construct a slice of Region's for given input. This regions contains ranges of non line\-break symbols from left to right. Return value could be used as Parser.LineIndex. Also Parser.Parse calls Parser.LineRegions for you automatically.

<a name="Parser.Locate"></a>
### func \(\*Parser\) [Locate](<https://github.com/corpix/parse/blob/master/parse.go#L111>)

```go
func (p *Parser) Locate(position int) (int, int)
```

Locate finds a line & column of the given position. It expects Parser.LineIndex to be a sorted slice of Region's of non line\-break's. If there is no LineIndex then it returns 0, 0.

<a name="Parser.Parse"></a>
### func \(\*Parser\) [Parse](<https://github.com/corpix/parse/blob/master/parse.go#L160>)

```go
func (p *Parser) Parse(r Rule, input []byte) (*Tree, error)
```

Parse parses input with Rule's. Calls Parser.LineRegions and store result under Parser.LineIndex. Not safe for concurrent use \(and not expected to be used concurrently\).

<a name="ParserOption"></a>
## type [ParserOption](<https://github.com/corpix/parse/blob/master/parse.go#L42>)

ParserOption represents a Parser option which mutates Parser in a way which is acceptable for this option.

```go
type ParserOption func(*Parser)
```

<a name="ParserOptionLineBreak"></a>
### func [ParserOptionLineBreak](<https://github.com/corpix/parse/blob/master/parse.go#L52>)

```go
func ParserOptionLineBreak(r Rule) ParserOption
```

ParserOptionLineBreak set parser line\-break Rule. Line\-breaks used during error reporting, they are not consumed and available for otherr rules.

<a name="ParserOptionMaxDepth"></a>
### func [ParserOptionMaxDepth](<https://github.com/corpix/parse/blob/master/parse.go#L45>)

```go
func ParserOptionMaxDepth(d int) ParserOption
```

ParserOptionMaxDepth set max depth for rule application recursion.

<a name="ParserOptionPath"></a>
### func [ParserOptionPath](<https://github.com/corpix/parse/blob/master/parse.go#L58>)

```go
func ParserOptionPath(path string) ParserOption
```

ParserOptionPath set parser path meta\-information which is propagated to each Rule.

<a name="PrefixMatcher"></a>
## type [PrefixMatcher](<https://github.com/corpix/parse/blob/master/matcher.go#L65>)

PrefixMatcher represents a Matcher which is true when chain\(which should be matched\) has the specified prefix.

```go
type PrefixMatcher []string
```

<a name="NewPrefixMatcher"></a>
### func [NewPrefixMatcher](<https://github.com/corpix/parse/blob/master/matcher.go#L73>)

```go
func NewPrefixMatcher(prefix []string) PrefixMatcher
```

NewPrefixMatcher creates new PrefixMatcher.

<a name="PrefixMatcher.Match"></a>
### func \(PrefixMatcher\) [Match](<https://github.com/corpix/parse/blob/master/matcher.go#L68>)

```go
func (m PrefixMatcher) Match(chain []string) bool
```

Match checks chain has prefix m.

<a name="Regexp"></a>
## type [Regexp](<https://github.com/corpix/parse/blob/master/regexp.go#L10-L15>)

Regexp is a Rule which should match Go regexp on input.

```go
type Regexp struct {
    name   string
    Regexp *regexp.Regexp
    Expr   string
    Hooks  []RuleParseHook
}
```

<a name="NewRegexp"></a>
### func [NewRegexp](<https://github.com/corpix/parse/blob/master/regexp.go#L99>)

```go
func NewRegexp(name string, expr string, hooks ...RuleParseHook) *Regexp
```

NewRegexp constructs a new \*Regexp.

<a name="Regexp.GetChilds"></a>
### func \(\*Regexp\) [GetChilds](<https://github.com/corpix/parse/blob/master/regexp.go#L39>)

```go
func (r *Regexp) GetChilds() Treers
```

GetChilds returns a slice of Rule which is children for current Rule.

<a name="Regexp.GetParameters"></a>
### func \(\*Regexp\) [GetParameters](<https://github.com/corpix/parse/blob/master/regexp.go#L46>)

```go
func (r *Regexp) GetParameters() RuleParameters
```

GetParameters returns a KV rule parameters.

<a name="Regexp.IsFinite"></a>
### func \(\*Regexp\) [IsFinite](<https://github.com/corpix/parse/blob/master/regexp.go#L55>)

```go
func (r *Regexp) IsFinite() bool
```

IsFinite returns true if this rule is not a wrapper for other rules.

<a name="Regexp.Name"></a>
### func \(\*Regexp\) [Name](<https://github.com/corpix/parse/blob/master/regexp.go#L19>)

```go
func (r *Regexp) Name() string
```

Name indicates the name which was given to the rule on creation. Name could be not unique.

<a name="Regexp.Parse"></a>
### func \(\*Regexp\) [Parse](<https://github.com/corpix/parse/blob/master/regexp.go#L63>)

```go
func (r *Regexp) Parse(ctx *Context, input []byte) (*Tree, error)
```

Parse consumes some bytes from input & emits a Tree using settings defined during creation of the concrete Rule type. May return an error if something goes wrong, should provide some location information to the user which points to position in input.

<a name="Regexp.Show"></a>
### func \(\*Regexp\) [Show](<https://github.com/corpix/parse/blob/master/regexp.go#L23>)

```go
func (r *Regexp) Show(childs string) string
```



<a name="Regexp.String"></a>
### func \(\*Regexp\) [String](<https://github.com/corpix/parse/blob/master/regexp.go#L33>)

```go
func (r *Regexp) String() string
```

String returns rule as a string, resolving recursion with \`\<circular\>\` placeholder.

<a name="Region"></a>
## type [Region](<https://github.com/corpix/parse/blob/master/region.go#L5-L8>)

Region represents a starting and ending points of something. It could be a position of '\(' and '\)' in 'foo\(bar\)' for example.

```go
type Region struct {
    Start int
    End   int
}
```

<a name="TreeRegion"></a>
### func [TreeRegion](<https://github.com/corpix/parse/blob/master/region.go#L11>)

```go
func TreeRegion(tree ...*Tree) *Region
```

TreeRegion constructs a \*Region from the one or more \*Tree.

<a name="Repetition"></a>
## type [Repetition](<https://github.com/corpix/parse/blob/master/repetition.go#L27-L33>)

Repetition is a Rule which is repeating in the input one or more times.

```go
type Repetition struct {
    name     string
    Rule     Rule
    Times    int
    Variadic bool
    Hooks    []RuleParseHook
}
```

<a name="NewRepetition"></a>
### func [NewRepetition](<https://github.com/corpix/parse/blob/master/repetition.go#L227>)

```go
func NewRepetition(name string, rule Rule, hooks ...RuleParseHook) *Repetition
```

NewRepetition constructs new \*Repetition which releat one or more times.

<a name="NewRepetitionTimes"></a>
### func [NewRepetitionTimes](<https://github.com/corpix/parse/blob/master/repetition.go#L204>)

```go
func NewRepetitionTimes(name string, times int, rule Rule, hooks ...RuleParseHook) *Repetition
```

NewRepetitionTimes constructs new \*Repetition which repeats exactly \`times\`.

<a name="NewRepetitionTimesVariadic"></a>
### func [NewRepetitionTimesVariadic](<https://github.com/corpix/parse/blob/master/repetition.go#L216>)

```go
func NewRepetitionTimesVariadic(name string, times int, rule Rule, hooks ...RuleParseHook) *Repetition
```

NewRepetitionTimesVariadic constructs new variadic \*Repetition which repeats exactly \`times\` or more.

<a name="Repetition.GetChilds"></a>
### func \(\*Repetition\) [GetChilds](<https://github.com/corpix/parse/blob/master/repetition.go#L62>)

```go
func (r *Repetition) GetChilds() Treers
```

GetChilds returns a slice of Rule which is children for current Rule.

<a name="Repetition.GetParameters"></a>
### func \(\*Repetition\) [GetParameters](<https://github.com/corpix/parse/blob/master/repetition.go#L69>)

```go
func (r *Repetition) GetParameters() RuleParameters
```

GetParameters returns a KV rule parameters.

<a name="Repetition.IsFinite"></a>
### func \(\*Repetition\) [IsFinite](<https://github.com/corpix/parse/blob/master/repetition.go#L79>)

```go
func (r *Repetition) IsFinite() bool
```

IsFinite returns true if this rule is not a wrapper for other rules.

<a name="Repetition.Name"></a>
### func \(\*Repetition\) [Name](<https://github.com/corpix/parse/blob/master/repetition.go#L37>)

```go
func (r *Repetition) Name() string
```

Name indicates the Name which was given to the rule on creation. Name could be not unique.

<a name="Repetition.Parse"></a>
### func \(\*Repetition\) [Parse](<https://github.com/corpix/parse/blob/master/repetition.go#L87>)

```go
func (r *Repetition) Parse(ctx *Context, input []byte) (*Tree, error)
```

Parse consumes some bytes from input & emits a Tree using settings defined during creation of the concrete Rule type. May return an error if something goes wrong, should provide some location information to the user which points to position in input.

<a name="Repetition.Show"></a>
### func \(\*Repetition\) [Show](<https://github.com/corpix/parse/blob/master/repetition.go#L46>)

```go
func (r *Repetition) Show(childs string) string
```

Show this node as a string. You should provide childs as string to this function, it does not care about nesting in a tree, it only shows string representation of itself.

<a name="Repetition.String"></a>
### func \(\*Repetition\) [String](<https://github.com/corpix/parse/blob/master/repetition.go#L56>)

```go
func (r *Repetition) String() string
```

String returns rule as a string, resolving recursion with \`\<circular\>\` placeholder.

<a name="Rule"></a>
## type [Rule](<https://github.com/corpix/parse/blob/master/rule.go#L44-L59>)

Rule represents a general Rule interface.

```go
type Rule interface {
    Treer

    // Parameters returns a KV rule parameters.
    GetParameters() RuleParameters

    // IsFinite returns true if this rule is
    // not a wrapper for other rules.
    IsFinite() bool

    // Parse consumes some bytes from input & emits a Tree
    // using settings defined during creation of the concrete Rule type.
    // May return an error if something goes wrong, should provide some
    // location information to the user which points to position in input.
    Parse(ctx *Context, input []byte) (*Tree, error)
}
```

<a name="_"></a>

```go
var _ Rule = new(Chain)
```

<a name="_"></a>

```go
var _ Rule = new(Either)
```

<a name="_"></a>

```go
var _ Rule = new(Regexp)
```

<a name="_"></a>

```go
var _ Rule = new(Repetition)
```

<a name="_"></a>

```go
var _ Rule = new(Terminal)
```

<a name="_"></a>

```go
var _ Rule = new(Wrapper)
```

<a name="RuleParameters"></a>
## type [RuleParameters](<https://github.com/corpix/parse/blob/master/rule.go#L11>)

RuleParameters is a key\-value mapping of the Rule custom settings.

```go
type RuleParameters map[string]interface{}
```

<a name="RuleParameters.String"></a>
### func \(RuleParameters\) [String](<https://github.com/corpix/parse/blob/master/rule.go#L14>)

```go
func (p RuleParameters) String() string
```

String encodes a RuleParameters as string.

<a name="RuleParseHook"></a>
## type [RuleParseHook](<https://github.com/corpix/parse/blob/master/rule.go#L41>)



```go
type RuleParseHook = func(ctx *Context, t *Tree) error
```

<a name="Rules"></a>
## type [Rules](<https://github.com/corpix/parse/blob/master/rules.go#L4>)

Rules is just a alias for the list of Rule.

```go
type Rules []Rule
```

<a name="SomeMatcher"></a>
## type [SomeMatcher](<https://github.com/corpix/parse/blob/master/matcher.go#L40>)

SomeMatcher represents a Matcher which wraps a slice of Matcher where some\(one of\) Matcher should match for the wrapper to be true.

```go
type SomeMatcher []Matcher
```

<a name="NewSomeMatcher"></a>
### func [NewSomeMatcher](<https://github.com/corpix/parse/blob/master/matcher.go#L56>)

```go
func NewSomeMatcher(matchers []Matcher) SomeMatcher
```

NewSomeMatcher creates new SomeMatcher.

<a name="SomeMatcher.Match"></a>
### func \(SomeMatcher\) [Match](<https://github.com/corpix/parse/blob/master/matcher.go#L46>)

```go
func (m SomeMatcher) Match(chain []string) bool
```

Match checks that some\(one of\) Matcher.Match\(...\) returns true and returns true too, otherwise it returns false. If no Matcher presented in a slice then it will return false.

<a name="SuffixMatcher"></a>
## type [SuffixMatcher](<https://github.com/corpix/parse/blob/master/matcher.go#L82>)

SuffixMatcher represents a Matcher which is true when chain\(which should be matched\) has the specified suffix.

```go
type SuffixMatcher []string
```

<a name="NewSuffixMatcher"></a>
### func [NewSuffixMatcher](<https://github.com/corpix/parse/blob/master/matcher.go#L90>)

```go
func NewSuffixMatcher(suffix []string) SuffixMatcher
```

NewSuffixMatcher creates new SuffixMatcher.

<a name="SuffixMatcher.Match"></a>
### func \(SuffixMatcher\) [Match](<https://github.com/corpix/parse/blob/master/matcher.go#L85>)

```go
func (m SuffixMatcher) Match(chain []string) bool
```

Match checks chain has suffix m.

<a name="Terminal"></a>
## type [Terminal](<https://github.com/corpix/parse/blob/master/terminal.go#L11-L15>)

Terminal is a Rule which is literal in input.

```go
type Terminal struct {
    name  string
    Value []byte
    Hooks []RuleParseHook
}
```

<a name="NewTerminal"></a>
### func [NewTerminal](<https://github.com/corpix/parse/blob/master/terminal.go#L103>)

```go
func NewTerminal(name string, v string, hooks ...RuleParseHook) *Terminal
```

NewTerminal constructs a new \*Terminal.

<a name="Terminal.GetChilds"></a>
### func \(\*Terminal\) [GetChilds](<https://github.com/corpix/parse/blob/master/terminal.go#L39>)

```go
func (r *Terminal) GetChilds() Treers
```

GetChilds returns a slice of Rule which is children for current Rule.

<a name="Terminal.GetParameters"></a>
### func \(\*Terminal\) [GetParameters](<https://github.com/corpix/parse/blob/master/terminal.go#L46>)

```go
func (r *Terminal) GetParameters() RuleParameters
```

GetParameters returns a KV rule parameters.

<a name="Terminal.IsFinite"></a>
### func \(\*Terminal\) [IsFinite](<https://github.com/corpix/parse/blob/master/terminal.go#L55>)

```go
func (r *Terminal) IsFinite() bool
```

IsFinite returns true if this rule is not a wrapper for other rules.

<a name="Terminal.Name"></a>
### func \(\*Terminal\) [Name](<https://github.com/corpix/parse/blob/master/terminal.go#L19>)

```go
func (r *Terminal) Name() string
```

Name indicates the name which was given to the rule on creation. Name could be not unique.

<a name="Terminal.Parse"></a>
### func \(\*Terminal\) [Parse](<https://github.com/corpix/parse/blob/master/terminal.go#L63>)

```go
func (r *Terminal) Parse(ctx *Context, input []byte) (*Tree, error)
```

Parse consumes some bytes from input & emits a Tree using settings defined during creation of the concrete Rule type. May return an error if something goes wrong, should provide some location information to the user which points to position in input.

<a name="Terminal.Show"></a>
### func \(\*Terminal\) [Show](<https://github.com/corpix/parse/blob/master/terminal.go#L23>)

```go
func (r *Terminal) Show(childs string) string
```



<a name="Terminal.String"></a>
### func \(\*Terminal\) [String](<https://github.com/corpix/parse/blob/master/terminal.go#L33>)

```go
func (r *Terminal) String() string
```

String returns rule as a string, resolving recursion with \`\<circular\>\` placeholder.

<a name="Tree"></a>
## type [Tree](<https://github.com/corpix/parse/blob/master/tree.go#L10-L17>)

Tree represents a single Rule match with corresponding information about the input, position and matched Rule. It will be recursive in case of nested Rule match.

```go
type Tree struct {
    Rule     Rule
    Location *Location
    Region   *Region
    Depth    int
    Childs   []*Tree
    Data     []byte
}
```

<a name="Parse"></a>
### func [Parse](<https://github.com/corpix/parse/blob/master/parse.go#L198>)

```go
func Parse(rule Rule, input []byte) (*Tree, error)
```

Parse is a shortcut to call the DefaultParser.Parse\(\).

<a name="Tree.GetChilds"></a>
### func \(\*Tree\) [GetChilds](<https://github.com/corpix/parse/blob/master/tree.go#L28>)

```go
func (t *Tree) GetChilds() Treers
```

GetChilds returns a slice of the Treer with children nodes.

<a name="Tree.Graph"></a>
### func \(\*Tree\) [Graph](<https://github.com/corpix/parse/blob/master/tree.go#L68>)

```go
func (t *Tree) Graph() string
```

Graph produce Graphviz compatible code which could be converted to picture using, for example \`dot \-Tpng \> graph.png\`.

<a name="Tree.Hash"></a>
### func \(\*Tree\) [Hash](<https://github.com/corpix/parse/blob/master/tree.go#L61>)

```go
func (t *Tree) Hash() string
```

Hash produces a lication which is believed to uniquely identify the node in the tree. This is useful for serialization and graphing.

<a name="Tree.Name"></a>
### func \(\*Tree\) [Name](<https://github.com/corpix/parse/blob/master/tree.go#L20>)

```go
func (t *Tree) Name() string
```

Name returns current node name.

<a name="Tree.Show"></a>
### func \(\*Tree\) [Show](<https://github.com/corpix/parse/blob/master/tree.go#L41>)

```go
func (t *Tree) Show(childs string) string
```

Show this node as a string. You should provide childs as string to this function, it does not care about nesting in a tree, it only shows string representation of itself.

<a name="Tree.String"></a>
### func \(\*Tree\) [String](<https://github.com/corpix/parse/blob/master/tree.go#L53>)

```go
func (t *Tree) String() string
```



<a name="Tree.graph"></a>
### func \(\*Tree\) [graph](<https://github.com/corpix/parse/blob/master/tree.go#L80>)

```go
func (t *Tree) graph() string
```

graph is a helper for Graph, and called in non root nodes.

<a name="Treer"></a>
## type [Treer](<https://github.com/corpix/parse/blob/master/treer.go#L4-L24>)

Treer is a tree node interface.

```go
type Treer interface {
    // Name returns current node name.
    Name() string

    // Show this node as a string.
    // You should provide childs as string
    // to this function, it does not care
    // about nesting in a tree, it only shows
    // string representation of itself.
    Show(childs string) string

    // String returns a tree string representation
    // from current node to the leafs.
    // You should use `TreerString(Treer) string` func
    // inside your implementation because it will resolve
    // the loops counting visited nodes.
    String() string

    // GetChilds returns a slice of the Treer with children nodes.
    GetChilds() Treers
}
```

<a name="FindFirstDFSPrefix"></a>
### func [FindFirstDFSPrefix](<https://github.com/corpix/parse/blob/master/treer_walk.go#L208>)

```go
func FindFirstDFSPrefix(tree Treer, prefix []string) (Treer, bool)
```



<a name="FindFirstDFSSuffix"></a>
### func [FindFirstDFSSuffix](<https://github.com/corpix/parse/blob/master/treer_walk.go#L239>)

```go
func FindFirstDFSSuffix(tree Treer, suffix []string) (Treer, bool)
```



<a name="Treers"></a>
## type [Treers](<https://github.com/corpix/parse/blob/master/treers.go#L3>)



```go
type Treers []Treer
```

<a name="Wrapper"></a>
## type [Wrapper](<https://github.com/corpix/parse/blob/master/wrapper.go#L7-L11>)

Wrapper represents a wrapper type for some inner Rule. It could be used to wrap a Rule with custom name.

```go
type Wrapper struct {
    name  string
    Rule  Rule
    Hooks []RuleParseHook
}
```

<a name="NewWrapper"></a>
### func [NewWrapper](<https://github.com/corpix/parse/blob/master/wrapper.go#L124>)

```go
func NewWrapper(name string, r Rule, hooks ...RuleParseHook) *Wrapper
```

NewWrapper constructs new Wrapper.

<a name="Wrapper.GetChilds"></a>
### func \(\*Wrapper\) [GetChilds](<https://github.com/corpix/parse/blob/master/wrapper.go#L40>)

```go
func (r *Wrapper) GetChilds() Treers
```

GetChilds returns a slice of Rule which is children for current Rule.

<a name="Wrapper.GetParameters"></a>
### func \(\*Wrapper\) [GetParameters](<https://github.com/corpix/parse/blob/master/wrapper.go#L47>)

```go
func (r *Wrapper) GetParameters() RuleParameters
```

GetParameters returns a KV rule parameters.

<a name="Wrapper.IsFinite"></a>
### func \(\*Wrapper\) [IsFinite](<https://github.com/corpix/parse/blob/master/wrapper.go#L55>)

```go
func (r *Wrapper) IsFinite() bool
```

IsFinite returns true if this rule is not a wrapper for other rules.

<a name="Wrapper.Name"></a>
### func \(\*Wrapper\) [Name](<https://github.com/corpix/parse/blob/master/wrapper.go#L15>)

```go
func (r *Wrapper) Name() string
```

Name indicates the name which was given to the rule on creation. Name could be not unique.

<a name="Wrapper.Parse"></a>
### func \(\*Wrapper\) [Parse](<https://github.com/corpix/parse/blob/master/wrapper.go#L63>)

```go
func (r *Wrapper) Parse(ctx *Context, input []byte) (*Tree, error)
```

Parse consumes some bytes from input & emits a Tree using settings defined during creation of the concrete Rule type. May return an error if something goes wrong, should provide some location information to the user which points to position in input.

<a name="Wrapper.Show"></a>
### func \(\*Wrapper\) [Show](<https://github.com/corpix/parse/blob/master/wrapper.go#L24>)

```go
func (r *Wrapper) Show(childs string) string
```

Show this node as a string. You should provide childs as string to this function, it does not care about nesting in a tree, it only shows string representation of itself.

<a name="Wrapper.String"></a>
### func \(\*Wrapper\) [String](<https://github.com/corpix/parse/blob/master/wrapper.go#L34>)

```go
func (r *Wrapper) String() string
```

String returns rule as a string, resolving recursion with \`\<circular\>\` placeholder.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
